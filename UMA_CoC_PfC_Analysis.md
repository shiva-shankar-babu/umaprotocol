# UMA CoC > PfC Analysis

## 1. The CoC > PfC Concept (from Whitepaper v0.2, April 2020)

The UMA (Universal Market Access) protocol relies on an oracle system to bring real-world data onto the blockchain. The security of this oracle hinges on a core economic principle: the Cost of Corruption (CoC) must be greater than the Profit from Corruption (PfC).

- **Profit from Corruption (PfC):** This represents the potential financial gain an attacker could achieve by successfully corrupting an oracle vote. It is derived from the "value at risk" in the contracts that rely on the oracle. For example, if a contract holds $10 million in assets, the PfC could be considered $10 million.

- **Cost of Corruption (CoC):** This is the economic cost an attacker would incur to successfully manipulate an oracle vote. In UMA's system, this cost is primarily derived from the expense of acquiring a majority of the voting tokens (UMA tokens) needed to sway the outcome of a vote.

- **The Core Inequality (CoC > PfC):** For the UMA oracle to be considered secure, the cost to corrupt it must always exceed the potential profit from doing so. If PfC were higher than CoC, there would be a clear economic incentive to attack the oracle.

- **Enforcement Mechanism (as per the 2020 whitepaper):** The whitepaper outlines a dynamic system to maintain the CoC > PfC inequality. This involves:
    - A **variable fee policy**: Fees generated by the UMA protocol can be adjusted.
    - **Token buybacks and burns**: A portion of these fees can be used to buy UMA tokens from the market and subsequently burn them. This reduces the overall supply of UMA tokens, making it more expensive to acquire a majority (thus increasing CoC). The idea is that if the CoC gets dangerously close to the PfC, these mechanisms can be activated more aggressively to increase CoC and restore a healthy security margin.

## 2. Investigating PfC (Profit from Corruption) Implementation

Upon reviewing the UMA protocol's smart contracts (specifically focusing on versions around the time of the whitepaper and core concepts), the implementation of PfC is primarily handled as follows:

- **Individual Contract Responsibility:** Financial contract templates that are designed to interact with the UMA oracle system and pay fees typically inherit from a contract like `FeePayer.sol` (or a similar abstraction). This base contract mandates that deriving contracts define their own specific measure of "profit from corruption." This is done by implementing an internal virtual function, often named `_pfc()`. The `FeePayer.sol` contract would then expose a public or external view function, say `pfc()`, which simply returns the value from `_pfc()`.

  A simplified representation from a hypothetical `FeePayer.sol`:
  ```solidity
  // Within FeePayer.sol (illustrative example)
  contract FeePayer {
      // ... other fee-related logic ...

      /**
       * @notice Returns the profit from corruption for this specific contract.
       * @dev This value represents the total value that could be gained by successfully corrupting an oracle vote
       * for this contract. It should be implemented by concrete contract instances.
       */
      function pfc() public view virtual returns (uint256) {
          return _pfc();
      }

      /**
       * @notice Internal function to be implemented by child contracts to define their PfC.
       */
      function _pfc() internal view virtual returns (uint256);
  }
  ```

- **Role of `Registry.sol`:** The UMA protocol uses a `Registry.sol` contract (or a contract with similar registry functionality). Its primary role concerning financial contracts is to maintain a list of all officially registered contract instances. This is typically managed via a function like `registerContract(address newContract)` which adds the contract's address to an array, for example, `registeredContracts[]`. This allows the UMA system to be aware of all legitimate contracts interacting with its oracle.

- **No Centralized PfC Aggregation:** While each financial contract is responsible for defining its own `PfCcontract` (via its `_pfc()` implementation), the `Registry.sol` contract, in its typical implementation, does not appear to store these individual PfC values. More importantly, it does not seem to contain logic to iterate through all `registeredContracts`, call each one's `pfc()` function, and sum these values to compute a *total system-wide PfC*.

- **Implication for Automated Enforcement:** The 2020 whitepaper describes an enforcement mechanism where the system (presumably an on-chain component or automated off-chain process governed by on-chain parameters) would react if CoC gets too close to PfC. This reaction involves adjusting fees and using them for token buybacks/burns to increase CoC. However, if there's no on-chain mechanism to automatically and continuously calculate the *total system-wide PfC* by summing up the PfC from all active contracts, then the direct, automated feedback loop envisioned in the whitepaper (where the system autonomously detects PfC levels and reacts) is not clearly implemented in the core `Registry.sol` or `FeePayer.sol` architecture. The calculation of total PfC would likely rely on off-chain monitoring and manual or semi-automated governance actions to trigger the CoC-boosting measures.

## 3. Investigating CoC (Cost of Corruption) Implementation

The Cost of Corruption (CoC) in UMA is theoretically defined as the cost to acquire enough voting tokens to successfully manipulate an oracle vote. The whitepaper often presents this with a formula akin to `CoC = pfloor * y`, where `y` is the number of tokens needed for a majority (e.g., `y > (1-η)S/2` or `y > S/2` in simpler models), `S` is the total supply of voting tokens, `pfloor` is a "floor price" of the token, and `η` (eta) is the voter participation rate.

Examining the UMA smart contracts (e.g., `VotingToken.sol` and related DVM contracts) reveals the following regarding on-chain availability of CoC components:

- **Voting Token Supply (`S`):** The `VotingToken.sol` contract is an ERC20 token, often with snapshot capabilities (like those derived from OpenZeppelin's `ERC20Snapshot.sol`). The total supply of UMA voting tokens (`S`) at any given block (or a recent snapshot) is directly available on-chain via the `totalSupply()` or `totalSupplyAt(snapshotId)` function. This `S` is a crucial part of the CoC calculation, representing the total pool of tokens from which an attacker must acquire a majority.

- **External Data for Price (`p` or `pfloor`) and Participation (`η`):**
    - **Token Market Price (`p`):** The current market price of the UMA token, which would be used for `p` or to derive `pfloor` (a guaranteed minimum price, perhaps via a bonding curve or a commitment to buy at that price), is not intrinsically available within `VotingToken.sol` itself or other core DVM contracts. This price is determined by external markets (DEXs, CEXs) and would require an oracle to bring on-chain if needed for an on-chain CoC calculation.
    - **Voter Participation Rate (`η`):** While past voter participation for specific votes might be derivable by analyzing past voting events on-chain (e.g., in `OracleV1.sol` or `OracleV2.sol` by comparing total votes cast to total supply at the time of vote), the *anticipated* or *current average* participation rate (`η`) for a *future* potential attack is not a fixed value stored or calculated by the contracts. It's a dynamic, behavioral variable. For a specific price request being voted on, `η` is only known after the vote concludes.

- **Conclusion on On-Chain CoC Calculation:** The UMA smart contracts provide a reliable on-chain value for the total supply of voting tokens (`S`). However, other critical variables needed for a full, dynamic, and autonomous on-chain calculation of CoC (specifically, a reliable current price `p` or `pfloor`, and a relevant `η` for the liveness parameter) are not inherently calculated or stored by the examined DVM contracts. These are external data points. Consequently, an automated system that continuously compares an on-chain calculated total PfC with an on-chain calculated total CoC to trigger adjustments, as envisioned in the whitepaper's feedback loop, does not appear to be fully implemented directly within the core contracts. The CoC side of the inequality would also likely rely on off-chain data and calculations to inform governance or automated agents.

## 4. Investigating the Enforcement of CoC > PfC

The 2020 whitepaper proposed an automated enforcement loop where the system would adjust fees and perform token buybacks/burns if CoC approached PfC. The investigation into contracts like `Store.sol`, `Governor.sol`, and `GovernorV2.sol` (representing UMA's fee collection and governance mechanisms) reveals the following about this enforcement:

- **Fee Collection in `Store.sol`:** The `Store.sol` contract serves as a treasury or repository for fees collected from financial contracts. These fees are typically paid by financial contracts inheriting from `FeePayer.sol`, which facilitates the transfer of regular operational fees and final dispute-related fees to the `Store`. The rates for these fees (e.g., `fixedOracleFeePerSecondPerPfc` for ongoing fees, or `weeklyDelayFeePerSecondPerPfc` for late dispute fees, which are scaled by the contract's `pfc()`) are configurable parameters within `Store.sol`. These parameters are typically settable by an `owner` or administrative role, which in UMA's system, is controlled by governance.

- **Absence of Fully Automated Enforcement Loop:** Based on the reviewed contracts, there is no apparent on-chain, autonomous mechanism that:
    1.  Continuously calculates or retrieves a live system-wide total PfC (sum of all individual contract PfCs).
    2.  Continuously calculates or retrieves a live system-wide CoC (based on token supply, market price, and participation rates).
    3.  Compares these CoC and PfC values on-chain.
    4.  If CoC is not sufficiently greater than PfC, automatically adjusts the fee parameters in `Store.sol` to increase fee revenue.
    5.  Automatically directs the collected fees held in `Store.sol` to be used for UMA token buybacks from the market and subsequent burning of those tokens to increase CoC.

- **Governance-Mediated Enforcement:** While the fully *automated* feedback loop described in the 2020 whitepaper isn't directly implemented as a self-executing smart contract system, the UMA governance contracts (`Governor.sol`, `GovernorV2.sol`, and associated Timelock contracts) provide the necessary tools for UMA token holders to achieve the *objectives* of the CoC > PfC security framework. For instance, UMA token holders can create and vote on governance proposals to:
    - Modify fee parameters within `Store.sol` (e.g., increase `fixedOracleFeePerSecondPerPfc`). This would be a response to an off-chain assessment that PfC is growing or CoC is falling.
    - Authorize the withdrawal of accumulated fees from `Store.sol`. These funds could then be allocated to a multisig or a dedicated contract responsible for executing token buybacks on exchanges and burning them. This process, while initiated and authorized by on-chain governance, would likely involve off-chain execution for the buyback and burn operations themselves or interaction with specific burn-facilitating contracts.

- **Conclusion on Enforcement:** The enforcement of the CoC > PfC principle in the UMA protocol, as implemented in the examined contracts, appears to be a **governance-mediated process** rather than a fully autonomous, on-chain system. The tools for fee adjustment and utilization of collected fees are present, but their activation and strategic deployment rely on the active participation and decision-making of UMA token holders through the governance framework. This contrasts with the more autonomous "cruise control" system implied in the early whitepaper draft. Off-chain analysis and monitoring are essential to inform these governance decisions.

## 5. Conclusion on Implementation vs. Whitepaper (v0.2, April 2020)

This investigation set out to understand how the UMA protocol's smart contracts implement the CoC > PfC framework, particularly concerning the tracking and aggregation of PfC and the automated enforcement mechanisms described in the "UMA Oracle Paper v0.2" (April 2020).

**Key Whitepaper Components Present:**
Many foundational elements from the whitepaper are indeed implemented in the UMA smart contracts:
-   Individual financial contracts, through inheritance from `FeePayer.sol` (or similar contracts), are responsible for defining and reporting their potential Profit from Corruption (`PfCcontract`) via an internal `_pfc()` method. This value is made accessible through a `pfc()` view function.
-   Fees are levied on these financial contracts, with rates often proportional to their stated `PfCcontract`. These fees are collected and managed within `Store.sol` (or an equivalent treasury contract).
-   A `VotingToken.sol` (the UMA token) exists, and its total supply (`S`) is a knowable on-chain quantity, forming a basis for CoC calculations.

**Main Difference: Absence of Fully Autonomous On-Chain Loop:**
The most significant divergence from the 2020 whitepaper's vision is the absence of a fully *autonomous* on-chain feedback loop. The contracts reviewed do not appear to contain logic that:
1.  Automatically aggregates all individual `PfCcontract` values from every registered financial contract to derive a live, system-wide total PfC.
2.  Simultaneously calculates a dynamic, system-wide CoC based on real-time token market prices and voter participation rates.
3.  Continuously compares these total PfC and CoC values on-chain.
4.  Autonomously adjusts fee parameters in `Store.sol` or triggers token buybacks and burns using collected fees if the CoC margin over PfC is deemed insufficient.

**Achieving Economic Goals via Governance:**
Despite the absence of this specific automated loop, the UMA protocol's architecture, particularly through its governance mechanisms (`Governor.sol`, `GovernorV2.sol`), provides the means to achieve the same overarching economic goals of maintaining CoC > PfC. The system is flexible and allows UMA token holders to:
-   Monitor the relationship between estimated total PfC (which can be calculated off-chain by summing `pfc()` values from registered contracts) and estimated CoC (derived from market data and token supply).
-   Propose and enact changes to fee parameters in `Store.sol` if the CoC > PfC balance needs adjustment.
-   Propose and authorize the use of collected fees from `Store.sol` for strategic token buybacks and burns to bolster CoC.

This governance-mediated approach, while requiring active participation and off-chain analysis, offers adaptability. It allows for human judgment and response to evolving market conditions and security landscapes, which a rigidly defined autonomous system might struggle with.

**Addressing the Original Query on PfC Tracking:**
To directly answer the user's original query: "how the UMA protocol is tracking pfc across all its ecosystem contracts, whether it tracks, or the logic is not implemented."

-   **Individual Tracking:** Each UMA financial contract *does* track its own potential Profit from Corruption (`PfCcontract`) and makes this value available on-chain via its `pfc()` function (implemented from `FeePayer.sol`).
-   **No Automated Aggregation for Autonomous Control:** However, an on-chain system that *automatically aggregates* all these individual `pfc` values into a live, system-wide total PfC figure, which then *autonomously* drives on-chain fee adjustments or token buybacks as part of a closed loop, is **not apparent** in the examined core DVM smart contracts (e.g., `Registry.sol`, `Store.sol`, `FeePayer.sol`).
-   **Potential for Off-Chain/Governance-Initiated Aggregation:** The `Registry.sol` contract maintains a list of all registered financial contracts. This list makes it feasible to perform an aggregation of all individual `pfc()` values. This aggregation would likely be an *off-chain process* conducted by interested parties (e.g., the UMA team, community members, analytics services) or could be triggered by a specific governance action if a snapshot of total system PfC is needed for analytical purposes. This aggregated PfC data would then inform governance proposals rather than directly feeding into an autonomous on-chain control mechanism.

In essence, the mechanism for individual contracts to declare their PfC is implemented. The mechanism for the system to automatically use an aggregated, live total PfC to self-regulate, as depicted in the 2020 whitepaper, has been implemented as a more adaptable, governance-controlled process.
